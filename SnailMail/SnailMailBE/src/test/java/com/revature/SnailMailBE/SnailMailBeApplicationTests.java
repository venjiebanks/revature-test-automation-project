package com.revature.SnailMailBE;

import com.revature.SnailMailBE.models.Mail;
import com.revature.SnailMailBE.services.MailService;
import io.restassured.filter.log.RequestLoggingFilter;
import io.restassured.filter.log.ResponseLoggingFilter;
import io.restassured.response.Response;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.web.servlet.MockMvc;

import static io.restassured.RestAssured.given;
import static org.hamcrest.Matchers.*;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;

@SpringBootTest
@AutoConfigureMockMvc //<- IMPORTANT - This sets up MockMVC so we can send mock requests
class SnailMailBeApplicationTests {

	//Default test autogenerated by Spring Boot
	@Test
	void contextLoads() {
	}

	//First RestAssured test - Just makes sure getInbox() works as expected
	@Test
	void testGetInbox() {

		//Response object from RestAssured. Lets us extract and test HTTP Responses
		Response response = given()
				.when().get("http://localhost:8080/mail")
				.then().extract().response();

		//Now we can run assertions on the response
		response.then()
				.statusCode(200)
				.body("size()", greaterThan(0))
				.body("[0].sender", notNullValue())
				.body("[0].recipient", equalTo("me@snailmail.com"));
	}

	//NOTE: We used JUnit, which is great and for Java tests in general...
	//But RestAssured is built SPECIFICALLY for testing REST APIs

	//Second RestAssured test - Tests success sendMail
	@Test
	void testSendMailSuccess(){

		//valid mail object
		Mail mail = new Mail("me@snailmail.com",
				"Testing",
				"you@snailmail.com",
				"Hi");

		//Same pattern as usual - gather the response, make assertions on it
		Response response = given()
				.contentType("application/json")
				.body(mail)
				.when().post("http://localhost:8080/mail")
				.then().extract().response();

		response.then()
				.statusCode(200)
				.body("sender", equalTo("me@snailmail.com"));
				//TODO: we could check each field of course, but you get the point
	}

	//Third Test - sendMail fails with empty recipient
	@Test
	void testSendMailFailsOnMissingRecipient(){

		//Instantiate a mail object with a blank recipient
		Mail mail = new Mail("me@snailmail.com",
				"Testing",
				"",
				"Hi");

		//Same pattern as other tests-
		Response response = given()
				.contentType("application/json")
				.body(mail)
				.when().post("http://localhost:8080/mail")
				.then()
				.extract().response();

		response.then()
				.statusCode(400) //bad request
				.body("message", equalTo("Recipient cannot be empty!"));
	}

	//Fourth Test - sendMail fails with subject > 20 characters
	@Test
	void testSendMailFailsOnSubjectOver20Chars(){

		//Instantiate a mail object with a long subject
		Mail mail = new Mail("me@snailmail.com",
				"Hey pal yesterday I had a ham sandwich and wouldn't you know it, I thought it was roast beef. Imagine my surprise! Anyway the sandwich was made with homemade rye bread, my mother's recipe actually. You should try it sometime.",
				"you@snailmail.com",
				"Hi");

		//Same pattern as other tests-
		Response response = given()
				.contentType("application/json")
				.body(mail)
				.when().post("http://localhost:8080/mail")
				.then()
				.extract().response();

		response.then()
				.statusCode(400) //bad request
				.body("message", equalTo("Save it for the message body, buddy"));
	}

	//Fifth Test - login success (also adding two logging filters to this one!)
	@Test
	void successfulLoginCreatesNewSession(){

		//Define the JSON object for the request body
		String loginJson = """
				{
					"username": "username",
					"password": "password"
				}
				""";

		//Send the POST request, extract the response, assert stuff on it
		Response response = given()
				.filter(new RequestLoggingFilter()) //Log the request
				.filter(new ResponseLoggingFilter()) //Log the response
				.contentType("application/json")
				.body(loginJson)
				.when().post("http://localhost:8080/auth/login")
				.then().extract().response();

		//Assert 200 ok, assert session was set, assert user info is correct
		response.then()
				.statusCode(200)
				.body("username", equalTo("username"))
				.cookie("JSESSIONID", notNullValue());
	}

	//Sixth Test - use Mockito and MockMVC to test 204 on empty inbox

	//Some setup first

	//Mock MailService -
	//we'll use this to test the controller without calling real service methods
	@MockitoBean
	private MailService mockMailService;

	//This object will help us write mock HTTP requests -
	//so we can test strictly the controller logic, not depending on HTTP
	@Autowired
	private MockMvc mockMvc;


	@Test
	void returnsNoContentIfInboxIsEmpty() throws Exception {

		//Mock the service method call, and return null (simulates empty inbox)
		when(mockMailService.getInbox()).thenReturn(null);

		//Mock the HTTP request,
		//ensure the controller method does the right thing when inbox == null
		mockMvc.perform(get("/mail"))
				.andExpect(status().isNoContent()) //204 status code
				.andExpect(content().string("")); //Empty body

		//We've COMPLETELY isolated the controller logic
		//No real HTTP request was made, and no real service method was called
		//This is what it means to "test logic in isolation"

	}

}
